<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Blog by Henry Lewis]]></title><description><![CDATA[Developer passionate about tooling + developer experience. Web Engineer @ Sprout Social.]]></description><link>http://hjylewis.com</link><generator>RSS for Node</generator><lastBuildDate>Mon, 12 Apr 2021 18:58:57 GMT</lastBuildDate><item><title><![CDATA[Language and Engineering systems are ingrown]]></title><description><![CDATA[In some ways we can think about engineering systems in the same way linguists think about natural languages. Both can become ingrown and complex over time. How might we relate what we know about how "simpler" natural languages are formed to engineering teams and systems?]]></description><link>http://hjylewis.com/posts/language-engineering-systems-ingrown/</link><guid isPermaLink="false">http://hjylewis.com/posts/language-engineering-systems-ingrown/</guid><pubDate>Thu, 05 Nov 2020 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;&lt;img src=&quot;/media/alice-donovan-rouse-yu68fUQDvOI-unsplash.jpg&quot; alt=&quot;Photo by Alice Donovan Rouse on Unsplash&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;human-languages-are-ingrown&quot;&gt;&lt;a href=&quot;#human-languages-are-ingrown&quot; aria-label=&quot;human languages are ingrown permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Human Languages are Ingrown&lt;/h2&gt;
&lt;p&gt;A major theme of linguist &lt;a href=&quot;https://en.wikipedia.org/wiki/John_McWhorter&quot;&gt;John McWhorter’s&lt;/a&gt; book &lt;a href=&quot;https://bookshop.org/books/what-language-is-and-what-it-isn-t-and-what-it-could-be/9781592407200&quot;&gt;“What Language Is (And What It Isn’t and What It Could Be)”&lt;/a&gt; is that languages become ingrown over time. What he means by this is it is natural for human languages to develop complexities and quirks when left alone over time. McWhorter compares languages to kudzu, “they grow hungrily, ceaselessly, and rampantly into available space, here sprouting multiple plural markers, there conjugating verbs differently according to whether they are about doing something to something (like throwing) or just about experiencing something (like falling)“. In fact, of the thousands of spoken languages in the world, it is much more common to have gendered words or odd categorization flourishes and have more exceptions than rules.
McWhorter explains that there are a number of reasons why this is. Though we often think of language as something that is written and documented, in actuality, language is something that is spoken. Language has been spoken for far longer than it has been written (150,000 years instead of 5,500 years). In fact, a great number of languages in the world have no written component. This makes languages much more flexible and subject to change than people realize. You can think of language as a lower fidelity projection of reality into grammar and vocabulary. As reality changes (politically or culturally), language must also change.
Since language changes, grammar rules collide and conflict causing edge cases and exceptions to emerge. In this way, languages become ingrown and more complex.&lt;/p&gt;
&lt;h2 id=&quot;engineering-systems--teams-are-ingrown&quot;&gt;&lt;a href=&quot;#engineering-systems--teams-are-ingrown&quot; aria-label=&quot;engineering systems  teams are ingrown permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Engineering systems + teams are Ingrown&lt;/h2&gt;
&lt;p&gt;In these ways, languages are similar to systems developed by teams of engineers. As time goes on and different constraints and requirements emerge, the system must evolve. With a changing system, business logic written a couple of months ago might be stretched further and collide with other rules. Components might be reused in ways that were unthought off when they were originally designed. Edge cases and exceptions emerge and complexity seeps into the design. Think of this as the natural &lt;a href=&quot;https://twitter.com/cramforce/status/1139925981051801600&quot;&gt;entropy of systems&lt;/a&gt;.&lt;/p&gt;
&lt;blockquote class=&quot;twitter-tweet&quot;&gt;&lt;p lang=&quot;en&quot; dir=&quot;ltr&quot;&gt;Yesterday I overheard &amp;quot;Easy-to-replace systems tend to get replaced with hard-to-replace systems.&amp;quot; and now I can&amp;#39;t stop thinking about whether this is just a restatement of the second law of thermodynamics in terms of systems design.&lt;/p&gt;&amp;mdash; Malte Ubl (@cramforce) &lt;a href=&quot;https://twitter.com/cramforce/status/1139925981051801600?ref_src=twsrc%5Etfw&quot;&gt;June 15, 2019&lt;/a&gt;&lt;/blockquote&gt; 
&lt;p&gt;Engineers might identify this as a good time to refactor the design of a system. With the constraints and requirements we know now, we might re-design the system differently than when we had originally.
What would refactoring a human language look like?&lt;/p&gt;
&lt;h2 id=&quot;refactoring-language&quot;&gt;&lt;a href=&quot;#refactoring-language&quot; aria-label=&quot;refactoring language permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Refactoring Language&lt;/h2&gt;
&lt;p&gt;Some languages are more ingrown than others. Languages spoken by people with less exposure to other communities or cut off in some way (think languages spoken on islands) tend to become more ingrown than languages spoken by people who speak other languages. This is because children are good at learning complex languages, adults aren’t. When languages are more isolated and it is only children learning them, they continue to become more complex and ingrown. When languages are in a position where adults are learning them due to trade, imperialism, slavery, or any number of political or cultural reasons, they tend to evolve to become simpler so that adults can learn them easier. When adults have to learn second languages, those languages tend to become simplified over time. Good examples are English which was learned by Vikings in the 8th century A.D. and Persian which was the primary trade language of the Persian Empire and spoken all over the Middle East. I like to think of these simplifications to languages like refactoring. They revisit what is required of the language and smooth out some of the more complex rules and exceptions. They come about when a new person has to learn an ingrown language.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Disclaimer: No metaphors are perfect. I am not advocating for the spoken languages to be “refactored” in the same way that engineering systems are.  Ease of learning is not necessarily the “goal” of a natural spoken language unlike constructed (programming) languages and systems. Natural languages are in many ways an organic byproduct of culture, history, and politics of the people speaking them. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;new-engineers-simplify-systems&quot;&gt;&lt;a href=&quot;#new-engineers-simplify-systems&quot; aria-label=&quot;new engineers simplify systems permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;New Engineers simplify systems&lt;/h2&gt;
&lt;p&gt;I believe ingrown engineering systems are similar. Engineers on a team that maintains a system understand the history behind the exceptions. They understand what deadlines, third party libraries, external issues, and the lack of resources contributed to some of the edge cases and quirks. They might be too close to that history to see what might be confusing about the system. New engineers learning the system for the first time feel the rough edges more acutely. They can identify where the complexities lay and how a system can be refactored to be simpler. Like adults learning a second language, an engineer learning a new system is only seeing the final, ingrown product and not the history that leads up to it. With that perspective, they can see what is confusing and where changes can be made to smooth out the complexities. They can work with existing engineers to identify and refactor confusing elements of the system.
I believe that rotating new engineers between teams is key to maintaining simple systems. It is also important for existing engineers to listen to the fiction that newer engineers identify because it is harder for existing engineers to notice those same frustrations. Without new eyes, systems become ingrown and overly complex without the perspective to understand why they are confusing.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Design System Residency Write-up]]></title><description><![CDATA[I was able to help the Design Systems team at Sprout Social propose a residency program, and I participated as the first resident. A residency program is a way for developers and designers to join the Design Systems team for a period of time before returning to their normal product teams. I was able to complete several valuable projects as well as learn more about our systems, collaborating as a product organization, and how residency programs can work within an organization.]]></description><link>http://hjylewis.com/posts/design-system-residency/</link><guid isPermaLink="false">http://hjylewis.com/posts/design-system-residency/</guid><pubDate>Sat, 01 Feb 2020 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;&lt;img src=&quot;/media/harpal-singh-_zKxPsGOGKg-unsplash.jpg&quot; alt=&quot;Photo by Harpal Singh on Unsplash&quot;&gt;&lt;/p&gt;
&lt;p&gt;At the end of 2019, I was able to help the &lt;a href=&quot;https://seeds.sproutsocial.com/&quot;&gt;Design Systems&lt;/a&gt; team at Sprout Social propose a residency program, and I participated as the first resident. A residency program is a way for developers and designers to join the Design Systems team for a period of time before returning to their normal product teams. I was able to complete several valuable projects as well as learn more about our systems, collaborating as a product organization, and how residency programs can work within an organization. I talk more about the value of rotating new engineers to work on existing systems &lt;a href=&quot;/posts/language-engineering-systems-ingrown/&quot;&gt;here&lt;/a&gt;. My projects focused on making contributions to the Design System’s component library, internally known as &lt;a href=&quot;https://seeds.sproutsocial.com/components/&quot;&gt;Racine&lt;/a&gt;, easier and less confusing and build tools to help educate the users of the library. &lt;/p&gt;
&lt;h2 id=&quot;what-did-i-work-on&quot;&gt;&lt;a href=&quot;#what-did-i-work-on&quot; aria-label=&quot;what did i work on permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;What did I work on?&lt;/h2&gt;
&lt;h3 id=&quot;svg-icon-linter&quot;&gt;&lt;a href=&quot;#svg-icon-linter&quot; aria-label=&quot;svg icon linter permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;SVG Icon Linter&lt;/h3&gt;
&lt;p&gt;Contributors of icons to Racine might have noticed a Design Systems team member reviewing each one and suggesting changes to clean up and optimize the file. At Sprout, we commit our icon SVG files to the Racine repository. This gives us a single source of truth for the icons we use around our application. Often these icon SVGs are pulled from different places and are inconsistent or include unnecessary information for one reason or another. Having cleaner icon SVGs means having icons that are faster, more consistent, and overall easier to maintain. The Design Systems team manually reviewed incoming icon SVGs and suggested changes, which the contributor would then need to incorporate and then submit again. This was a slow and tedious process. Despite the Design Systems team’s commitment to the review process, this was simply not scalable as we continue to add and maintain more and more icons.&lt;/p&gt;
&lt;p&gt;This is where automation and tooling can help us! By exploring what changes the Design System team was requesting, we could work to distill those steps into something we could run on every icon modification and addition. We utilized a tool called &lt;a href=&quot;https://github.com/svg/svgo&quot;&gt;svgo&lt;/a&gt; which is a plugin-based tool for optimizing SVG files. This tool gave us the flexibility to enforce different custom rules for our SVG files. I was able to wrap a command-line interface (CLI) around svgo so that we could run it on staged files on commit and the entire codebase during Continuous Integration (CI). &lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/linting-output.png&quot; alt=&quot;cli output of icon linter&quot;&gt;&lt;/p&gt;
&lt;p&gt;We have a set of default and custom rules turned on that will strip out elements and attributes that are unnecessary and in general clean up and optimize our icons. This CLI tool is used on commit on staged files (think prettier for icons!) for that instant feedback and cleaner git log. It is also used as part of Racine’s pull request CI so that unchecked icons SVGs don’t slip through the cracks.&lt;/p&gt;
&lt;p&gt;What’s great about building the linter in a flexible manner is that it opens the door to developing future custom optimizations and fine-tuning the process. The development of a tool or CI is never done; it is an ongoing process. &lt;/p&gt;
&lt;p&gt;As the Design Systems team learns of friction points or possible improvements they can adjust the process so that the tooling serves the developers. You never want linters and validation CI to put up roadblocks and create work without a good reason and those reasons can change over time. The flexibility of this tool hopefully means that the framework can remain as the inevitable adjustments to the process happen over time.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;In fact, since first writing this, the Design Systems team has adjusted the icon development process. Now the source of truth for icons is in Figma (a design tool) and owned by designers. The icons get exported from Figma, run through the icon linter, and merged into the Github repo for their use in the application. Due to the flexibility of the linter, adjusting the process was remarkably easy. &lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;documentation-site-deprecation&quot;&gt;&lt;a href=&quot;#documentation-site-deprecation&quot; aria-label=&quot;documentation site deprecation permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Documentation site Deprecation&lt;/h3&gt;
&lt;p&gt;A major project for the Design Systems team for the past couple of years has been creating and maintaining a component library called Racine (often referred to as Racine 2 for reasons that will become clear) separate from the Sprout application code. Before that, web developers had been using a component library also called Racine (or Racine 1) that was embedded and entangled in the application code. Racine 1 had its own documentation site that was built with the web application. Now that Racine 2 is widely used and reached a parity with Racine 1 that we were comfortable with, we decided it was time to deprecate the use of Racine 1. This means deprecating the documentation site. Having two Racines and two documentation sites is confusing, especially for new hires. Plus, it was slowing down the application build times for something no longer widely used.&lt;/p&gt;
&lt;p&gt;Deprecation is not the same thing as deleting. We did not want to completely delete the Racine 1 documentation because we knew there might be developers who still use it or might need it in the future. But we still wanted to dissuade its use and point developers to Racine 2 instead. &lt;/p&gt;
&lt;p&gt;The default behavior of something can be a powerful tool for persuasion. I modified the default behavior of the Sprout application’s build process to deprecate the Racine 1 documentation. Instead of always building the documentation by default, I switched it to only build the documentation when you passed a flag. This way, developers would only build the documentation when they explicitly ask for it. This sped up the average build times for the application and still allowed the Racine 1 documentation to be accessible if needed. If a developer tries to navigate to the documentation page without building them, they will see a message pointing them to use the flag. This increases the visibility of the flag that is now necessary to access the documentation.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/deprecation-message-build.png&quot; alt=&quot;Deprecation message in build output&quot;&gt;&lt;/p&gt;
&lt;p&gt;This all helps with build times and deprecates the use of Racine 1 documentation. But the code powering the documentation site still exists in the application repo. This is code that can confuse developers and add to repository bloat. We want to tidy up after ourselves when we know the documentation site isn’t used anymore. How do we know when we can fully remove that code? I added a trigger to the Racine documentation site that will log whenever someone visits the site. This gives us the observability and transparency into how many people are using the flag to build and view the Racine 1 documentation. If we find after several months that no one is using the Racine 1 documentation it will be relatively safe to go back and delete it from our codebase. This observability affords us the confidence to remove the deprecated code knowing that no one is using it.&lt;/p&gt;
&lt;h3 id=&quot;racine-1-component-deprecation&quot;&gt;&lt;a href=&quot;#racine-1-component-deprecation&quot; aria-label=&quot;racine 1 component deprecation permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Racine 1 Component Deprecation&lt;/h3&gt;
&lt;p&gt;Another part of deprecating Racine 1 and moving developers to Racine 2 is the deprecation of Racine 1 components. There are many components in Racine 1 that have equivalents in Racine 2 that are newer and currently being maintained. It is confusing to have two components that do the same thing and we want to make it obvious which one developers should use. Similar to the Racine 1 documentation deprecation project, we want to dissuade the continued use of the deprecated components without outright banning their use (there are used in many places, and forcing the immediate removal of them would take its toll on the product roadmap and most likely introduce bugs). We need a transitory state where we can prevent the new use of the deprecated components and track the existing use of them while still allowing developers to ship product features.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/media/lint-deprecation-message.png&quot; alt=&quot;Deprecation linting rule&quot;&gt;&lt;/p&gt;
&lt;p&gt;I was able to utilize some existing tooling in the Sprout application to achieve these goals. ESlint is a tool we use in the application to enforce rules about how we write code. There is a rule that allows you to mark specific exports (in this case components) as deprecated with a custom message. Then whenever a file imports that export, the developer will get a warning saying to use the equivalent component in Racine 2. This gives developers inline feedback and allows them to learn that a component that they are trying to use is deprecated and discover newer components while they are writing code. Instead of checking and maintaining a document susceptible to falling out of date, eslint rules alert you to deprecations while you write code. By colocating this information with when you would need it, the information is not forgotten and more likely kept up to date. ESlint alone will not track nor allow existing uses of deprecated components. For that, we can use a tool called Esplint. Esplint allows and tracks existing violations of an eslint rule while preventing new violations. Read more about it &lt;a href=&quot;/posts/how-to-painlessly-turn-on-eslint-rules/&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Armed with the ESlint deprecation rule and Esplint, we can specify all the Racine 1 components with Racine 2 equivalents as deprecated. When a developer tries to import those components, they will be pointed to a better, newer alternative. Existing uses of those deprecated components will remain in the codebase with a warning so that developers can go back and switch them out in their own time. This dissuades the continued use of the deprecated components without outright banning their use. It also helps us track the current usage so that eventually we can remove the code for the deprecated components entirely. What is also great about these solutions is that it is not Racine specific. We can use these tools to deprecate anything in the application codebase. If we need to migrate the application to new number formatting utility functions, we can deprecate the old ones and point them to the new ones (we already do this with our deprecated number formatters!).&lt;/p&gt;
&lt;p&gt;Deprecation is a powerful tool when it comes to migrating developers to a newer, better solution (in this case Racine). It helps educate developers by pointing them to the right solution without forcing them to block their product roadmaps. Both the documentation site and component deprecation highlight some powerful solutions when it comes to phasing out features. We have the concept of using defaults and inlined/colocated information to educate and persuade behavior away from the deprecated feature. Another concept is still allowing the use of the deprecated feature in cases when developers still need access (we can’t anticipate 100% of future use-cases so we need some continued accessibility). We don’t want to force them to change anything unless it’s critical or time-sensitive. And observability into usage so that we can eventually tidy up and remove the feature fully. These concepts will help you deprecate and eventually remove any feature smoothly.&lt;/p&gt;
&lt;h2 id=&quot;the-residency-itself&quot;&gt;&lt;a href=&quot;#the-residency-itself&quot; aria-label=&quot;the residency itself permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;The Residency itself&lt;/h2&gt;
&lt;p&gt;I was able to participate as the first Design Systems resident for the month of December 2019 and half of January 2020. There were a lot of things that worked well and some things that could use work. I just want to call out a few things that worked well or could use some work. One of the most valuable meetings I had with the Design Systems team at the beginning of the residency was our brainstorming meeting. We met and brainstormed issues and possible solutions with the Design Systems currently. I came out of that meeting with a lot of great ideas and a better idea of what things I could be working on for the next month and a half (many of which I was able to complete over the course of the residency). I found that meeting to be a very valuable way of kicking off the residency since we arrived at projects that interested and inspired me.&lt;/p&gt;
&lt;p&gt;One of the areas that could use improvement is the structure of the residency. Often I felt isolated from any team and working in limbo. I do think a lot of this had to do with the Holidays and PTO schedules not lining up or the lack of an end date but it is something to pay attention to. I know I am the only person who likes stand-ups, but some sort of formalized check-in process would help the resident make progress and avoid flailing in place. I think I was able to accomplish a lot on my own since I am more familiar with Design Systems and Racine and had a good idea of how I was going to complete the projects; I worry about a less experienced resident left to their own devices. Some sort of structure to the residency could go a long way to help in this area.&lt;/p&gt;
&lt;p&gt;All in all, I think residency programs could be the right path for Sprout and other organizations. I still believe in a lot of the benefits outlined in the original proposal. I believe they can help with education, knowledge transfer, give developers opportunities to own larger projects, and staffing issues. I think exposure to other teams and projects even temporarily can &lt;a href=&quot;/posts/language-engineering-systems-ingrown/&quot;&gt;help a lot with cross-organization communication and system simplification&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;key-learnings&quot;&gt;&lt;a href=&quot;#key-learnings&quot; aria-label=&quot;key learnings permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Key Learnings&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Deprecation&lt;/strong&gt; is a powerful tool when switching to a newer system. It clearly communicates the desired developer behavior without forcing it too early.&lt;/li&gt;
&lt;li&gt;Changing the &lt;strong&gt;default behavior&lt;/strong&gt; of a system can be enough to push users/developers toward your desired outcome.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Colocation of documentation&lt;/strong&gt; will make sure that users/developers have the information when they actually need it and will also help keep eyes on the documentation and keep it up-to-date.&lt;/li&gt;
&lt;li&gt;Make sure you have &lt;strong&gt;observability into the usage&lt;/strong&gt; of deprecated systems so you know when you can delete things! Deprecation is not the end goal, it’s a means to delete something. So make sure you know when you can switch from deprecation to deletion. &lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Validation CI/Linters should be flexible&lt;/strong&gt; so it’s not a roadblock. Adjustments to process are inevitable so make sure your CI has the ability to adapt. If a CI is too brittle, you’ll find yourself rewriting it before you know it. &lt;/li&gt;
&lt;/ul&gt;</content:encoded></item><item><title><![CDATA[How to painlessly turn on ESLint rules]]></title><description><![CDATA[Linting is a powerful way to catch bad code and enforce best practices. That said, turning a rule on for an existing project can be difficult. esplint is a tool that makes it easier to introduce new ESLint rules to large, legacy codebases by tracking, enforcing, and updating file and rule scoped warning counts.]]></description><link>http://hjylewis.com/posts/how-to-painlessly-turn-on-eslint-rules/</link><guid isPermaLink="false">http://hjylewis.com/posts/how-to-painlessly-turn-on-eslint-rules/</guid><pubDate>Sat, 08 Jun 2019 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;&lt;img src=&quot;/media/yung-chang-108329-unsplash.jpg&quot; alt=&quot;Photo by Yung Chang on Unsplash&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/hjylewis/esplint&quot;&gt;esplint&lt;/a&gt; is an ESLint warning tracker to help introduce rules into a legacy code base.&lt;/p&gt;
&lt;h3 id=&quot;this-tool-will&quot;&gt;&lt;a href=&quot;#this-tool-will&quot; aria-label=&quot;this tool will permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;This tool will…&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Allow you the benefits of turning on a new ESLint immediately without forcing you to fix all the violations first.&lt;/li&gt;
&lt;li&gt;Prevent future violations from being introduced.&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;this-tool-wont&quot;&gt;&lt;a href=&quot;#this-tool-wont&quot; aria-label=&quot;this tool wont permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;This tool won’t…&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Automatically fix ESLint violations for you.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;the-problem&quot;&gt;&lt;a href=&quot;#the-problem&quot; aria-label=&quot;the problem permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;The Problem&lt;/h2&gt;
&lt;p&gt;Linting is a powerful way to catch bad code and enforce best practices. By statically analyzing your code, linters create fast, consistent feedback loops that can flag bad practices, anti-patterns, and typos. They are great for educating developers by providing descriptions and resources for best practices. The JS community at large has embraced the power of linting through tools like &lt;a href=&quot;https://eslint.org/&quot;&gt;ESLint&lt;/a&gt; with its robust plugin ecosystem.&lt;/p&gt;
&lt;p&gt;That said, turning on a new linting rule for an existing project can be difficult. When working with legacy codebases with a lot of code, each new rule can mean hundreds of violations that need to be fixed before the rule can be properly turned on. All codebases, regardless of their age, will have this issue eventually since new ESLint rules being created constantly. Who knows what will be a pattern today but an anti-pattern tomorrow?! Turning on rules can be very painful, surfacing hidden violations that you must fix before you can use the rule at all.&lt;/p&gt;
&lt;h2 id=&quot;past-solutions&quot;&gt;&lt;a href=&quot;#past-solutions&quot; aria-label=&quot;past solutions permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Past Solutions&lt;/h2&gt;
&lt;h3 id=&quot;using-eslint-warnings&quot;&gt;&lt;a href=&quot;#using-eslint-warnings&quot; aria-label=&quot;using eslint warnings permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Using ESLint Warnings&lt;/h3&gt;
&lt;p&gt;In general, it is good practice to have your linter block your continuous integration (CI) so that violations don’t get introduced to your codebase. This means in order to introduce a new ESLint rule, one would need to fix every violation. However, this wouldn’t be the case if we could classify these new violations as “non-blocking”. We can use ESLint’s warnings for this purpose. ESLint returns an error exit status if it finds violations of rules configured to &lt;code class=&quot;language-text&quot;&gt;error&lt;/code&gt; but not violations of rules configured to &lt;code class=&quot;language-text&quot;&gt;warn&lt;/code&gt;. If we turn on a new rule as a warning, we can introduce a new rule and not be blocked while fixing all the new violations. Warnings are great way to educate codebase contributors. We can work on fixing the newly exposed violations later without blocking anyone and then eventually switch the rule from &lt;code class=&quot;language-text&quot;&gt;warn&lt;/code&gt; to &lt;code class=&quot;language-text&quot;&gt;error&lt;/code&gt; when all the violations are fixed. However, ESLint’s warnings alone will not prevent new violations from being introduced the way that errors do by nature of them not blocking CI. If you fix 1 violation per 2 being introduced, you’ll never finish!&lt;/p&gt;
&lt;h3 id=&quot;using-eslint-max-warnings&quot;&gt;&lt;a href=&quot;#using-eslint-max-warnings&quot; aria-label=&quot;using eslint max warnings permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Using ESLint Max Warnings&lt;/h3&gt;
&lt;p&gt;ESLint does let you set a &lt;a href=&quot;https://eslint.org/docs/user-guide/command-line-interface#options&quot;&gt;cap on the number of warnings&lt;/a&gt;. For example, &lt;code class=&quot;language-text&quot;&gt;eslint --max-warnings 100&lt;/code&gt;. If your codebase has more warnings than that number, ESLint fails, otherwise, it passes. We can use this feature to prevent new violations from being introduced while the new rule is still a warning. We just set the max number of warnings to the initial number of violations, then if someone accidentally tries to introduce a new violation, ESLint will block the CI. As the warning count does down, we can manually lower the max number. This is a better solution but still has some issues:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;What if someone fixes a violation in one file but accidentally introduces one somewhere else? The count will still be under the max, ESLint will still pass but a new violation was introduced.&lt;/li&gt;
&lt;li&gt;What if we want to introduce a second new rule? That count has to be the sum of the number of violations. How will we know when we’re ready to turn one of the rules on as an &lt;code class=&quot;language-text&quot;&gt;error&lt;/code&gt;?&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;What I am illustrating is that this approach is scoped too generally. We only have a totally warning count to enforce. There are no file or rule specific counts.&lt;/p&gt;
&lt;h3 id=&quot;using-eslint-disable-comments&quot;&gt;&lt;a href=&quot;#using-eslint-disable-comments&quot; aria-label=&quot;using eslint disable comments permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Using ESLint disable comments&lt;/h3&gt;
&lt;p&gt;Another solution is turning on the new rule as an &lt;code class=&quot;language-text&quot;&gt;error&lt;/code&gt; and disabling ESLint for the specific violating lines using ESLint’s &lt;a href=&quot;https://eslint.org/docs/user-guide/configuring#disabling-rules-with-inline-comments&quot;&gt;disable comments&lt;/a&gt;. This definitely solves some of the issues we had with the previous situations. This is more specifically scoped, scoped to the violating code. It won’t block introducing the new rule until all the violations are fixed and it will block CI if new violations are added. However, it does go against the point of turning on the rule. By disabling ESLint on those lines, you are suppressing the potential warnings you’d be getting, missing out on the education that ESLint rules provide, and basically giving up on ever fixing those hidden violations.&lt;/p&gt;
&lt;h2 id=&quot;introducing-esplint&quot;&gt;&lt;a href=&quot;#introducing-esplint&quot; aria-label=&quot;introducing esplint permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Introducing esplint!&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/hjylewis/esplint&quot;&gt;esplint&lt;/a&gt; is a tool that allows you to turn new rules on as warnings, and prevent further violations while being scoped by file and rule. esplint is built on top of ESLint and uses it under the hood. Running esplint tracks the number of ESLint warnings per file and per rule, and prevents the number of warnings from increasing. When the number of warnings decreases, esplint records the new lower number automatically. This way you can introduce a new rule and fix existing legacy violations over time while avoiding further violations.&lt;/p&gt;
&lt;p&gt;Running esplint runs ESLint and creates a record file called &lt;code class=&quot;language-text&quot;&gt;.esplint.rec.json&lt;/code&gt; that stores information about the number of warnings per file and per rule. This works in a similar manner to lock files for npm and yarn and should be committed with your code. When esplint is run again, it will error if any of those counts get larger and update the counts if they get smaller. esplint encourages you to run esplint as part of our pre-commit hook using &lt;a href=&quot;https://github.com/okonet/lint-staged&quot;&gt;lint-staged&lt;/a&gt;. Since it runs ESLint underhood, it can even replace your ESLint pre-commit hook. See the &lt;a href=&quot;https://github.com/hjylewis/esplint#getting-started&quot;&gt;Getting Started README&lt;/a&gt; for more information.&lt;/p&gt;
&lt;p&gt;If you just want the checking functionality of esplint and not the automatic updating of counts, you can use the &lt;code class=&quot;language-text&quot;&gt;esplint --no-write&lt;/code&gt; option. The option &lt;code class=&quot;language-text&quot;&gt;esplint --overwrite&lt;/code&gt; is provided as an escape hatch for situations when introducing a new violation cannot be avoided. In those cases, esplint will disregard your existing &lt;code class=&quot;language-text&quot;&gt;.esplint.rec.json&lt;/code&gt; and will not error if a warning count increases.&lt;/p&gt;
&lt;p&gt;For a readable list of files with violations and total warning counts run &lt;code class=&quot;language-text&quot;&gt;esplint stats&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id=&quot;things-i-learned&quot;&gt;&lt;a href=&quot;#things-i-learned&quot; aria-label=&quot;things i learned permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Things I learned&lt;/h2&gt;
&lt;h3 id=&quot;the-perils-of-writing-to-disk&quot;&gt;&lt;a href=&quot;#the-perils-of-writing-to-disk&quot; aria-label=&quot;the perils of writing to disk permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;The perils of writing to disk&lt;/h3&gt;
&lt;p&gt;Given their use of lock files, esplint is closer to npm or yarn than ESLint since it leaves a necessary artifact on disk to be committed to the codebase. This can add complexity and introduces the problem of merge conflicts. Whenever there is a central file on disk that many team members can touch, accidental merge conflicts have to be considered. esplint has gone through multiple improvements to avoid issues of merge conflicts.&lt;/p&gt;
&lt;p&gt;In my initial approach, the record file was unsorted and included information for every file, even those that contained no violations. Whenever a new file was added to the codebase, it’s &lt;code class=&quot;language-text&quot;&gt;.esplint.rec.json&lt;/code&gt; entry would be added. Since the record file was unsorted, this meant the entry was always added to the bottom of the file. This obviously created conflicts when multiple people created new files in separate branches. Spoiler alert, I found out this happens a lot! Changing the file to store records in sorted order helped avoid a majority of unnecessary merge conflicts. Removing entries for files with zero violations from the record file also helped reduce merge conflicts. Further, it greatly reduced the size of the record files themselves. This change reduced the length of record files by a hundredfold in some codebases.&lt;/p&gt;
&lt;p&gt;While these modifications improved the lock files, they didn’t prevent merge conflicts in the record file completely. Git doesn’t understand JSON format and only understands lines being removed and added. Git can get confused when violations are being fixed in separate branches so that multiple lines of the record file are being removed. In this case, running &lt;code class=&quot;language-text&quot;&gt;esplint&lt;/code&gt; will attempt to automatically resolve the git conflict similar to how npm resolves lock files.&lt;/p&gt;
&lt;h3 id=&quot;fail-loudly&quot;&gt;&lt;a href=&quot;#fail-loudly&quot; aria-label=&quot;fail loudly permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Fail loudly&lt;/h3&gt;
&lt;p&gt;Sometimes it can be more beneficial to fail loudly than fail gracefully but silently. An early version of esplint would fail gracefully when it encountered a record file that wasn’t valid JSON. It would continue on as if it were starting from scratch, ignoring the invalid record file. This made sense at the time as an appropriate way of handling an invalid record. But this would also cause esplint to analyze the entire codebase the same way that it does when no record exists. This can be very slow depending on the size of the codebase.&lt;/p&gt;
&lt;p&gt;When an esplint user accidentally committed a corrupt record file to their repository, others started reporting very slow esplint times on the pre-commit hook which was confusing and hurt productivity. It took a while to discover the invalid JSON and understand what was happening. It wasn’t helpful that esplint was silently pretending everything was all right and it made it harder to track down the cause. Now, instead of failing silently, esplint fails in this situation with a helpful error message that lets the user know that the record file was corrupt.&lt;/p&gt;
&lt;h3 id=&quot;the-danger-of-warning-fatigue&quot;&gt;&lt;a href=&quot;#the-danger-of-warning-fatigue&quot; aria-label=&quot;the danger of warning fatigue permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;The danger of warning fatigue&lt;/h3&gt;
&lt;p&gt;Unfortunately, even with esplint, violations will not fix themselves! Depending on your team, contributors might not be motivated to fix warnings on their own. At work, we’ve found success focusing on one new rule at a time and scheduling hacking sessions where we work to resolve violations. &lt;a href=&quot;https://en.wikipedia.org/wiki/Alarm_fatigue&quot;&gt;Warning fatigue&lt;/a&gt; is real and focusing on one at a time can mean introducing new rules faster.&lt;/p&gt;
&lt;h2 id=&quot;summary&quot;&gt;&lt;a href=&quot;#summary&quot; aria-label=&quot;summary permalink&quot; class=&quot;anchor&quot;&gt;&lt;svg aria-hidden=&quot;true&quot; focusable=&quot;false&quot; height=&quot;16&quot; version=&quot;1.1&quot; viewBox=&quot;0 0 16 16&quot; width=&quot;16&quot;&gt;&lt;path fill-rule=&quot;evenodd&quot; d=&quot;M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z&quot;&gt;&lt;/path&gt;&lt;/svg&gt;&lt;/a&gt;Summary&lt;/h2&gt;
&lt;p&gt;esplint will make it easier to introduce new ESLint rules to large, legacy codebases by tracking, enforcing, and updating file and rule scoped warning counts.&lt;/p&gt;
&lt;p&gt;For more detail about getting started, usage, and configuration see the &lt;a href=&quot;https://github.com/hjylewis/esplint#esplint&quot;&gt;README&lt;/a&gt;.&lt;/p&gt;</content:encoded></item></channel></rss>